以前正常内核崩溃现场转存是kdump吧，就会i崩溃时切换到内存的第二套内核代码运行然后把崩溃内核的内存复制出来。
但kdump通常过于重量级了，其实只要崩溃时那个oops信息就能定位大部分问题吧。


oops信息如果有窗口线或者其他console口，直接看终端日志就行。但linux内核崩溃的问题不好说什么时候，大多时候都没有条件连着串口线等十天半个月，不知道内核什么时候崩溃呢。 之前试过一下netconsole, 但好像不管用。


之前看到了pstore（Persistent Storage File System），这就是我想要的东西吧，能记录下崩溃oops, 内核崩溃重启后日志能保存查看这个崩溃日志。
https://blogs.oracle.com/linux/post/pstore-linux-kernel-persistent-storage-file-system



```text
# Enable PSTORE support
CONFIG_PSTORE=y
CONFIG_PSTORE_DEFAULT_KMSG_BYTES=10240
CONFIG_PSTORE_COMPRESS=y
CONFIG_PSTORE_DEFLATE_COMPRESS=y

# Enable UEFI pstore backend
CONFIG_EFI_VARS_PSTORE=y
CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE=y

# Enable ACPI ERST pstore backend
CONFIG_ACPI=y
CONFIG_ACPI_APEI=y
```

大部分的发行版默认都支持pstore了，debian 13 默认打开了 efi 后端。
```text
$ sudo cat  /sys/module/efi_pstore/parameters/pstore_disable 
N
$ sudo cat  /sys/module/pstore/parameters/backend 
efi_pstore
```

有的比较老的内核，好像默认 没有打开的，要改grub 的linux启动参数里面加上下面这个。
```text
pstore.backend=efi efi_pstore.pstore_disable=0
```

efi 后端，应该是存到efivars（UEFI variable storage backend）里面的，UEFI 模式启动的系统才能使用EFI 提供的这个接口吧。
```text
~$ lsmod | grep efi
efi_pstore             12288  0
efivarfs               28672  1

~$ modinfo pstore
name:           pstore
filename:       (builtin)
license:        GPL
file:           fs/pstore/pstore
description:    Persistent Storage - platform driver interface
author:         Tony Luck <tony.luck@intel.com>
parm:           update_ms:milliseconds before pstore updates its content (default is -1, which means runtime updates are disabled; enabling this option may not be safe; it may lead to further corruption on Oopses) (int)
parm:           backend:specific backend to use (charp)
parm:           compress:compression to use (charp)
parm:           kmsg_bytes:amount of kernel log to snapshot (in bytes) (uint)

ming@ming:~$ modinfo efi_pstore
filename:       /lib/modules/6.12.48+deb13-amd64/kernel/drivers/firmware/efi/efi-pstore.ko.xz
alias:          platform:efivars
license:        GPL
description:    EFI variable backend for pstore
import_ns:      EFIVAR
depends:        
intree:         Y
name:           efi_pstore
retpoline:      Y
vermagic:       6.12.48+deb13-amd64 SMP preempt mod_unload modversions 
sig_id:         PKCS#7
signer:         Build time autogenerated kernel key
sig_key:        3B:36:CA:EA:C9:EE:29:4C:D7:F4:B8:B2:F7:ED:1C:1E:67:0E:AA:86
sig_hashalgo:   sha256
signature:      30:64:02:30:07:A0:C0:D2:BD:6C:8A:1B:25:33:87:AB:20:80:5F:FC:
		2A:52:9C:27:5D:7C:59:08:B5:A9:87:24:81:C7:F0:59:F2:21:39:30:
		89:F9:A0:B0:29:56:E4:72:12:5A:A1:6D:02:30:1B:7C:AD:1C:B9:9D:
		DA:A0:71:E8:AB:ED:17:6E:2F:62:8F:37:30:60:53:84:C8:3C:72:5F:
		97:52:80:10:43:8E:53:A0:B7:34:BA:6D:02:F1:F8:6E:62:B8:F3:AB:
		D6:72
parm:           record_size:size of each pstore UEFI var (in bytes, min/default=1024) (uint)
parm:           pstore_disable:bool

```

日志的查看，挂载/sys/fs/pstore 里面，如果系统崩溃，可以重启后在这个目录看到崩溃的oops信息，里面文件跟常规文件一样可以删除。
默认应该是保存的dmesg信息了，但好像通过配置也可以用来存储其他日志的。
```text
mount -t pstore /sys/fs/pstore 
````

pstore的存储后端，除了 EFI ，最初还有一个“ACPI ERST”， 看文档还有 “ramoops” 和 “pstore-blk”。
https://kernel.org/doc/html/latest/admin-guide/ramoops.html
https://kernel.org/doc/html/latest/admin-guide/pstore-blk.html

ramoops 要在内核启动时就提前预留一段物理内存用于pstore, 类似kdump的机制吧，但我看了一下ramoops参数配置比较麻烦，不知道预留那一段地址比较合适，可能不同机器和硬件都要调整，通用性不是很好。
blk是预留一个磁盘分区，但好像磁盘驱动要支持特殊的panic_write 操作才行，不知道默认的磁盘是不是支持的，panic时的存储操作还是比较特殊的肯定不能枷锁或者依赖已经崩溃的内核。
ACPI 的我自己的机器 /sys/firmware/acpi/tables/ 目录下面也没有 ERST 表, 主板固件不支持吧
```text
~$ grep PSTORE  /boot/config-`uname -r` 
CONFIG_EFI_VARS_PSTORE=m
# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
# CONFIG_MTD_PSTORE is not set
CONFIG_CHROMEOS_PSTORE=m
CONFIG_PSTORE=y
CONFIG_PSTORE_DEFAULT_KMSG_BYTES=10240
CONFIG_PSTORE_COMPRESS=y
# CONFIG_PSTORE_CONSOLE is not set
# CONFIG_PSTORE_PMSG is not set
# CONFIG_PSTORE_FTRACE is not set
CONFIG_PSTORE_RAM=m
CONFIG_PSTORE_ZONE=m
CONFIG_PSTORE_BLK=m
CONFIG_PSTORE_BLK_BLKDEV=""
CONFIG_PSTORE_BLK_KMSG_SIZE=64
CONFIG_PSTORE_BLK_MAX_REASON=2
```





